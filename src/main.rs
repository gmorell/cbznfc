use std::time::Duration;
use std::thread::sleep;

use anyhow::{Error, Result};
use embedded_graphics::image::*;
use embedded_svc::wifi::Configuration as WifiConfiguration;
use embedded_svc::wifi::{ClientConfiguration, Wifi};
// use esp_idf_hal::i2c::*;
// use esp_idf_hal::spi::*;
use esp_idf_svc::wifi::EspWifi;
use esp_idf_hal::gpio;
use esp_idf_svc::hal::peripherals;
use esp_idf_svc::hal::timer::Timer;
use esp_idf_svc::nvs::EspDefaultNvsPartition;
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    hal::{
        i2c::{I2cConfig, I2cDriver},
        prelude::*,
    },
    http::server::{EspHttpServer},
};
use esp_idf_svc::hal::gpio::{AnyIOPin, PinDriver};
use esp_idf_svc::hal::spi::{SPI2, SpiDriver, SpiConfig, SpiDeviceDriver, SpiDriverConfig};
use log::info;
use display_interface_spi::{SPIInterface, SPIInterfaceNoCS};
use embedded_graphics::draw_target::DrawTarget;
use embedded_graphics::Drawable;
use embedded_graphics::pixelcolor::{Rgb565, RgbColor};
use embedded_graphics::prelude::Point;
use embedded_hal::spi::MODE_0;
use esp_idf_hal::gpio::Pin;
use esp_idf_hal::spi::SPI3;
use esp_idf_hal::timer::TimerDriver;
use esp_idf_hal::uart::{config, UartDriver};
use esp_idf_svc::hal::delay::Ets;
use mipidsi::{Builder, Orientation};
use pn532;
use pn532::{Pn532, Request};
use pn532::requests::SAMMode;
use pn532::serialport::{SerialPortInterface, SysTimer};


#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}



fn main() -> Result<(), Error>  {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // l'bits
    let peripherals = Peripherals::take()?;
    let sysloop = EspSystemEventLoop::take()?;
    let nvs = EspDefaultNvsPartition::take()?;

    // l'wifi
    let mut wifi_driver = EspWifi::new(
        peripherals.modem,
        sysloop,
        Some(nvs),
    )?;
    wifi_driver.set_configuration(
        &WifiConfiguration::Client(ClientConfiguration {
            ssid: app_config.wifi_ssid.try_into().expect("SSID does not fit into String<32> buffer"),
            password: app_config.wifi_psk.try_into().expect("Password does not fit into String<64> buffer"),
            ..Default::default()
        })
    )?;
    wifi_driver.start()?;
    wifi_driver.connect()?;
    while !wifi_driver.is_connected().unwrap() {
        let config = wifi_driver.get_configuration().unwrap();
        info!("Waiting for connection {:?}", config);
    }

    // l'spi
    let spi = peripherals.spi2;
    let rst = PinDriver::output(peripherals.pins.gpio1)?;

    let mut backlight = PinDriver::output(peripherals.pins.gpio10)?;
    let sck = peripherals.pins.gpio3;
    let dc = PinDriver::output(peripherals.pins.gpio6)?;
    let cs = peripherals.pins.gpio5;
    let mosi = peripherals.pins.gpio2;
    let miso_fk = peripherals.pins.gpio47;

    // let driver = SpiDriver::new::<SPI2>(spi, sck, mosi, None, &Default::default())?;
    let config = SpiConfig::new().baudrate(10.MHz().into());
    // let mut device = SpiDeviceDriver::new(&driver, Some(cs), &config)?;
    // let di = SPIInterface::new(device, dc);

    let device = SpiDeviceDriver::new_single(
        spi,
        sck,
        mosi,
        Some(miso_fk),
        Some(cs),
        &SpiDriverConfig::new(),
        &config,
    )?;

    // display interface abstraction from SPI and DC
    let di = SPIInterfaceNoCS::new(device, dc);

    let mut delay = Ets;
    let mut display = Builder::st7789(di)
        .with_display_size(128, 128)
        // set default orientation
        .with_orientation(Orientation::Portrait(false))
        // initialize
        .init(&mut delay, Some(rst))
        .unwrap();

    backlight.set_high()?;
    let raw_image_data = ImageRawLE::new(include_bytes!("../ferris.raw"), 86);
    let ferris = Image::new(&raw_image_data, Point::new(0, 0));

    display.clear(Rgb565::BLACK).unwrap();
    ferris.draw(&mut display).unwrap();


    // backlight.set_low()?;

    println!("Image printed!");


    // // i2c pn532
    // let timer = Timer::new();
    // let i2c = peripherals.i2c0;
    // let sda = peripherals.pins.gpio16;
    // let scl = peripherals.pins.gpio17;
    // let config = I2cConfig::new().baudrate(100.kHz().into());
    // let mut i2c = I2cDriver::new(i2c, sda, scl, &config)?;
    //
    //
    // let interface = I2CInterface {
    //     i2c: i2c,
    // };
    // let mut pn532: Pn532<_, _, 32> = Pn532::new(interface, timer);
    // if let Err(e) = pn532.process(&Request::sam_configuration(SAMMode::Normal, false), 0, 50.ms()){
    //     println!("Could not initialize PN532: {e:?}")
    // }
    // if let Ok(uid) = pn532.process(&Request::INLIST_ONE_ISO_A_TARGET, 7, 1000.ms()){
    //     let result = pn532.process(&Request::ntag_read(10), 17, 50.ms()).unwrap();
    //     if result[0] == 0x00 {
    //         println!("page 10: {:?}", &result[1..5]);
    //     }
    // }

    // spi pn532
    // let spi3 = peripherals.spi3;
    // let mosi = peripherals.pins.gpio16;
    // let ss = peripherals.pins.gpio17;
    // let miso = peripherals.pins.gpio18;
    // let sck = peripherals.pins.gpio48;
    //
    //
    //
    // let driver3 = SpiDriver::new::<SPI3>(
    //     spi3,
    //     sck,
    //     miso,
    //     Some(mosi),
    //     &SpiDriverConfig::new(),
    // )?;

    // let config_3 = config::Config::new().baudrate(26.MHz().into()).data_mode(MODE_0);
    // let mut device_1 = SpiDeviceDriver::new(&driver3, Some(ss), &config_3)?;
    // let timer = TimerDriver::new(peripherals.timer10, &Default::default());
    //
    // let interface = pn532::spi::SPIInterface {
    //     spi: device_1,
    //     cs: Some(ss),
    // };
    // let mut pn532: Pn532<_, _, 32> = Pn532::new(interface, timer);
    // if let Err(e) = pn532.process(&Request::sam_configuration(SAMMode::Normal, false), 0, 50.ms()){
    //     println!("Could not initialize PN532: {e:?}")
    // }
    // if let Ok(uid) = pn532.process(&Request::INLIST_ONE_ISO_A_TARGET, 7, 1000.ms()){
    //     let result = pn532.process(&Request::ntag_read(10), 17, 50.ms()).unwrap();
    //     if result[0] == 0x00 {
    //         println!("page 10: {:?}", &result[1..5]);
    //     }
    // }
    //

    // uart pn532

    let tx = peripherals.pins.gpio16;
    let rx = peripherals.pins.gpio17;

    let config = config::Config::new().baudrate(Hertz(115_200));
    let uart = UartDriver::new(
        peripherals.uart1,
        tx,
        rx,
        Option::<gpio::Gpio0>::None,
        Option::<gpio::Gpio1>::None,
        &config,
    )?;

    // let interface = SerialPortInterface { port: uart };
    let timer = TimerDriver::new(peripherals.timer10, &Default::default());
    let mut pn532: Pn532<_, _, 32> = Pn532::new(uart , timer);

    pn532.interface.send_wakeup_message().unwrap();
    if let Ok(fw) = pn532.process(
        &Request::GET_FIRMWARE_VERSION,
        4,
        Duration::from_millis(200),
    ) {
        println!("Firmware response: {:?}", fw);
    } else {
        println!("Unable to communicate with device.");
    }

    info!("Hello, world!");
    loop {
        info!("IP info: {:?}", wifi_driver.sta_netif().get_ip_info().unwrap());
        sleep(Duration::new(10, 0));
    }
}
